// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEditor;

//using NUnit.Framework;
using UnityEngine;
using System.IO;
using GQ.Util;
using System.Reflection;
using UnityEngine.Assertions;

namespace GQ.ET.Tests {
	[NUnit.Framework.TestFixture]
	public class FilesTest {

		DirectoryInfo originDir, targetDir;

		string[] jpgExtensions = new string[] {
			".jpg"
		};
		string[] pngExtensions = new string[] {
			".png"
		};
		string[] emptyExtensions = new string[] {
		};

		#region Setup & TearDown

		[NUnit.Framework.SetUp]
		public void SetUp () {
			originDir = Directory.CreateDirectory(GQTests.TestFilesDir + "FilesTest/origin/");
			createTestPNG(originDir.FullName + "testImage");
			createTestJPG(originDir.FullName + "testImage");

			targetDir = Directory.CreateDirectory(GQTests.TestFilesDir + "FilesTest/target/");
		}

		[NUnit.Framework.TearDown]
		public void TearDown () {
			Files.ClearDirectory(GQTests.TestFilesDir);
		}

		#endregion

		#region clear directory

		[NUnit.Framework.Test]
		public void clearDirectory () {
			// arrange:
			createTestJPG(targetDir.FullName + "shouldBeDeleted1");
			createTestJPG(targetDir.FullName + "shouldBeDeleted2");
			Directory.CreateDirectory(targetDir.FullName + "emptyDirShouldBeDeleted/");
			Directory.CreateDirectory(targetDir.FullName + "nonEmptyDirShouldBeDeleted/");
			createTestJPG(targetDir.FullName + "nonEmptyDirShouldBeDeleted/shouldBeDeleted");

			// pre assert:
			Assert.IsFalse(targetDir.GetDirectories().Length == 0, "target dir should contain any directories");
			Assert.IsFalse(targetDir.GetFiles().Length == 0, "target dir should contain any files");

			// act:
			Files.ClearDirectory(targetDir.FullName);

			// post assert:
			Assert.IsTrue(targetDir.GetDirectories().Length == 0, "target dir should not contain any directories");
			Assert.IsTrue(targetDir.GetFiles().Length == 0, "target dir should not contain any files");
		}

		void createTestPNG (string filePath) {
			// Create the file.
			using ( FileStream fs = File.Create(filePath + ".png") ) {
				Byte[] bytes = Texture2D.blackTexture.EncodeToPNG();
				// Add some information to the file.
				fs.Write(bytes, 0, bytes.Length);
				fs.Close();
			}
		}

		void createTestJPG (string filePath) {
			// Create the file.
			using ( FileStream fs = File.Create(filePath + ".jpg") ) {
				Byte[] bytes = Texture2D.blackTexture.EncodeToJPG();
				// Add some information to the file.
				fs.Write(bytes, 0, bytes.Length);
				fs.Close();
			}
		}

		#endregion

		#region exists

		[NUnit.Framework.Test]
		public void exists () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatExistsOnlyAfterCreated";

			// pre assert:
			Assert.IsFalse(Files.Exists(filePath, jpgExtensions), "file should not be found before it is created");
			Assert.IsFalse(Files.Exists(filePath, pngExtensions), "file should not be found before it is created");
			Assert.IsFalse(Files.ExistsImage(filePath), "file should not be found before it is created");

			// act:
			createTestJPG(filePath);
			createTestPNG(filePath);

			// post assert:
			Assert.IsTrue(Files.Exists(filePath, jpgExtensions), "file should have been found since it is already created");
			Assert.IsTrue(Files.Exists(filePath, pngExtensions), "file should have been found since it is already created");
			Assert.IsTrue(Files.ExistsImage(filePath), "file should have been found since it is already created");
		}

		[NUnit.Framework.Test]
		public void existImageWithEmptyExtensionArray () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatExistsOnlyAfterCreated";

			// pre assert:
			Assert.IsFalse(Files.Exists(filePath, emptyExtensions), "file should not be found before it is created");

			// act:
			createTestJPG(filePath);

			// post assert:
			Assert.IsFalse(Files.Exists(filePath, emptyExtensions), "file should not be found with empty extension array");
		}

		[NUnit.Framework.Test]
		public void existImageFindsJPG () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatExistsOnlyAfterCreated";

			// pre assert:
			Assert.IsFalse(Files.ExistsImage(filePath), "file should not be found before it is created");

			// act:
			createTestJPG(filePath);

			// post assert:
			Assert.IsTrue(Files.ExistsImage(filePath), "file should have been found since it is already created");
		}

		[NUnit.Framework.Test]
		public void existImageFindsPNG () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatExistsOnlyAfterCreated";
			
			// pre assert:
			Assert.IsFalse(Files.ExistsImage(filePath), "file should not be found before it is created");
			
			// act:
			createTestPNG(filePath);
			
			// post assert:
			Assert.IsTrue(Files.ExistsImage(filePath), "file should have been found since it is already created");
		}

		[NUnit.Framework.Test]
		public void existsNonExistingDir () {
			// arrange:
			string nonExistingDir = "this/is/a/non/existing/path/";
			string filename = "somefilename";
			
			// act:
			try {
				Assert.IsFalse(Files.Exists(nonExistingDir + filename, Files.ImageExtensions));
			} catch ( Exception exc ) {
				Assert.IsTrue(false, "Should not throw an exception, but threw: " + exc.Message);
			}
		}

		#endregion


		#region delete

		[NUnit.Framework.Test]
		public void deleteJPGFile () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatWillBeDeleted";
			createTestJPG(filePath);

			// pre assert:
			Assert.IsTrue(Files.Exists(filePath, jpgExtensions), "file should have been found since it is not yet deleted");

			// act:
			Files.Delete(filePath, jpgExtensions);

			// post assert:
			Assert.IsFalse(Files.Exists(filePath, jpgExtensions), "file should not have been found since it is deleted");
		}

		[NUnit.Framework.Test]
		public void deletePNGFile () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatWillBeDeleted";
			createTestPNG(filePath);
			
			// pre assert:
			Assert.IsTrue(Files.Exists(filePath, pngExtensions), "file should have been found since it is not yet deleted");
			
			// act:
			Files.Delete(filePath, pngExtensions);
			
			// post assert:
			Assert.IsFalse(Files.Exists(filePath, pngExtensions), "file should not have been found since it is deleted");
		}

		[NUnit.Framework.Test]
		public void deleteImageFiles () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatWillBeDeleted";
			createTestJPG(filePath);
			createTestPNG(filePath);
			
			// pre assert:
			Assert.IsTrue(Files.ExistsImage(filePath), "file should have been found since it is not yet deleted");
			
			// act:
			Files.DeleteImage(filePath);
			
			// post assert:
			Assert.IsFalse(Files.ExistsImage(filePath), "file should not have been found since it is deleted");
			Assert.IsFalse(Files.Exists(filePath, jpgExtensions), "no jpg file should be found since it is deleted");
			Assert.IsFalse(Files.Exists(filePath, pngExtensions), "no img file should be found since it is deleted");
		}

		[NUnit.Framework.Test]
		public void deleteNonExistingFile () {
			// arrange:
			string filePath = targetDir.FullName + "fileThatWillBeDeleted";

			// pre assert:
			Assert.IsFalse(Files.ExistsImage(filePath), "file should not have been found since it is not created");
			
			// act:
			Files.DeleteImage(filePath);
			
			// post assert:
			Assert.IsFalse(Files.ExistsImage(filePath), "file should not have been found since it is deleted");
		}

		[NUnit.Framework.Test]
		public void deleteFileInNonExistingDir () {
			// arrange:
			string nonExistingDir = "this/is/a/non/existing/path/";
			string filename = "somefilename";

			// pre assert:
			Assert.IsFalse(Files.ExistsImage(nonExistingDir + filename), "file should not have been found since the path does not exist");
			
			// act:
			try {
				Files.DeleteImage(nonExistingDir + filename);
			} catch ( Exception exc ) {
				// negative post assert:
				Assert.IsTrue(false, "Should not throw an exception, but threw: " + exc.Message);
			}
			
			// post assert:
			Assert.IsFalse(Files.ExistsImage(nonExistingDir + filename), "file should not have been found since it has never been created");
		}

		#endregion


		#region copy

		[NUnit.Framework.Test]
		public void copyJPGFile () {
			// arrange:
			string filename = "file";
			string originFile = originDir.FullName + filename;
			string targetFile = targetDir.FullName + filename;
			createTestJPG(originFile);

			// pre assert:
			Assert.IsTrue(Files.Exists(originFile, jpgExtensions));
			Assert.IsFalse(Files.Exists(targetFile, jpgExtensions));

			// act:
			Files.Copy(originFile, targetFile, jpgExtensions);

			// post assert:
			Assert.IsTrue(Files.Exists(originFile, jpgExtensions));
			Assert.IsTrue(Files.Exists(targetFile, jpgExtensions));

		}

		[NUnit.Framework.Test]
		public void copyPNGFile () {
			// arrange:
			string filename = "file";
			string originFile = originDir.FullName + filename;
			string targetFile = targetDir.FullName + filename;
			createTestPNG(originFile);
			
			// pre assert:
			Assert.IsTrue(Files.Exists(originFile, pngExtensions));
			Assert.IsFalse(Files.Exists(targetFile, pngExtensions));
			
			// act:
			Files.Copy(originFile, targetFile, pngExtensions);
			
			// post assert:
			Assert.IsTrue(Files.Exists(originFile, pngExtensions));
			Assert.IsTrue(Files.Exists(targetFile, pngExtensions));
			
		}

		[NUnit.Framework.Test]
		public void copyJPGOverwritingPNG () {
			// arrange:
			string filename = "file";
			string originFile = originDir.FullName + filename;
			string targetFile = targetDir.FullName + filename;
			createTestJPG(originFile);
			createTestPNG(targetFile);

			// pre assert:
			Assert.IsTrue(Files.Exists(originFile, Files.ImageExtensions), 
				"there should be a jpg image file at origin before we copy");
			Assert.IsTrue(Files.Exists(targetFile, Files.ImageExtensions), 
				"there should be a png image file at target before we copy");
			Assert.IsTrue(Files.Exists(targetFile, pngExtensions), 
				"there should be a png file at target before we copy");
			Assert.IsFalse(Files.Exists(targetFile, jpgExtensions), 
				"there should not be a jpg file at target before we copy");

			// act:
			Files.Copy(originFile, targetFile, Files.ImageExtensions);

			// post assert:
			Assert.IsTrue(Files.Exists(originFile, Files.ImageExtensions), 
				"there should still be a jpg image file at origin after we copy");
			Assert.IsTrue(Files.Exists(targetFile, Files.ImageExtensions), 
				"there should again be an image file at target after we copy");
			Assert.IsTrue(Files.Exists(targetFile, jpgExtensions), 
				"there should now be a jpg image file at target after we copy");
			Assert.IsFalse(Files.Exists(targetFile, pngExtensions), 
				"there should not be a png image file at target after we copy");
		}

		[NUnit.Framework.Test]
		public void copyImageFile () {
			// arrange:
			string filename = "file";
			string originFile = originDir.FullName + filename;
			string targetFile = targetDir.FullName + filename;
			createTestJPG(originFile);
			createTestPNG(originFile);

			// pre assert:
			Assert.IsTrue(Files.ExistsImage(originFile));
			Assert.IsFalse(Files.ExistsImage(targetFile));

			// act:
			Files.CopyImage(originFile, targetFile);
			
			// post assert:
			Assert.IsTrue(Files.ExistsImage(originFile));
			Assert.IsTrue(Files.ExistsImage(targetFile));
		}

		[NUnit.Framework.Test]
		public void copyNonExistingOrigin () {
			// arrange:
			string nonExistingDir = "this/is/a/non/existing/path/";
			string filename = "somefilename";

			// act:
			try {
				Files.Copy(nonExistingDir + filename, targetDir.FullName + filename, jpgExtensions);
			} catch ( Exception exc ) {
				// negative post assert:
				Assert.IsTrue(false, "Should not throw an exception, but threw: " + exc.Message);
			}
			
			// post assert:
			Assert.IsFalse(Files.ExistsImage(targetDir.FullName + filename), "file should not have been found since it was not copied");
		}

		[NUnit.Framework.Test]
		public void checkOurProblem () {
			try {
				Files.Copy("Assets/ConfigAssets/Resources/splashScreen", "Assets/Editor/productPlaceholders/splashScreen", Files.ImageExtensions);
			} catch ( Exception exc ) {
				// negative post assert:
				Assert.IsTrue(false, "Should not throw an exception, but threw: " + exc.Message);
			}
		}

		#endregion

		#region PlayerSettings Reflection Experiment

		[NUnit.Framework.Test]
		public void gatherFieldsOfPlayerSettings () {

			Assembly editorAsm = typeof(Editor).Assembly;
			Type playerSettingsType = editorAsm.GetType("UnityEditor.PlayerSettings");
			FieldInfo[] fields = playerSettingsType.GetFields(BindingFlags.Static | BindingFlags.NonPublic);
			Debug.Log("Found fields in PlayerSettings: ");
			foreach ( FieldInfo fi in fields ) {
				Debug.Log(fi.Name + (fi.IsPublic ? " (public)" : " (private)"));
			}

			PropertyInfo[] properties = playerSettingsType.GetProperties(BindingFlags.Static | BindingFlags.NonPublic);
			Debug.Log("Found properties in PlayerSettings: ");
			foreach ( PropertyInfo pi in properties ) {
				Debug.Log(pi.Name);
			}

			MemberInfo[] members = playerSettingsType.GetProperties(BindingFlags.Static | BindingFlags.NonPublic);
			Debug.Log("Found members in PlayerSettings: ");
			foreach ( MemberInfo membI in members ) {
				Debug.Log(membI.Name);
			}

			MethodInfo[] methods = playerSettingsType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic);
			MethodInfo internalGetPlayerSettingsObjectMethod;
			Type internalPS = null;
			Debug.Log("Found methods in PlayerSettings: ");
			foreach ( MethodInfo mi in methods ) {
				Debug.Log(mi.Name + (mi.IsPublic ? " (public)" : " (private)"));
				if ( mi.Name.Equals("InternalGetPlayerSettingsObject") ) {
					internalPS = mi.ReturnType;

					FieldInfo[] iFields = internalPS.GetFields(BindingFlags.Static | BindingFlags.NonPublic);
					Debug.Log("Found fields in internalPlayerSettings: ");
					foreach ( FieldInfo fi2 in iFields ) {
						Debug.Log(fi2.Name + (fi2.IsPublic ? " (public)" : " (private)"));
					}
					
					MethodInfo[] iMethods = internalPS.GetMethods(BindingFlags.Static | BindingFlags.NonPublic);
					Debug.Log("#### Found methods in internalPlayerSettings: ");
					foreach ( MethodInfo mi2 in iMethods ) {
						Debug.Log(mi2.Name + (mi2.IsPublic ? " (public)" : " (private)"));
					}

					Debug.Log("#### End of listing from internalPlayerSettings: ");
				}
			}

		}

		#endregion

	}
}

